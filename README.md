# Context-free grammar based java parser with pure java

### Goal

 본 프로젝트는 객체지향프로그래밍 수업의 과제를 위한 것으로, 목표는 주어진 [MyStack.java](./MyStack.java) 파일을 String으로 읽어 그 구조를 파악하고, 결과를 GUI로 나타내는 것이다.

### Approach

 이를 수행하려면 java 파일의 구조를 파악해야 한다. 물론, 과제에서는 각 함수가 참조하는 변수가 무엇인지, 클래스가 포함하는 field가 무엇인지 정도만을 출력하면 된다고 하였다. 그러므로 과제의 요구사항을 만족시키는 가장 간단한 방법은 스택이나 정규표현식을 사용한 매칭이다.(교수님께서 ANTLR 등 외부 라이브러리는 사용할 수 없다고 하였다.) 그러나 최근 컴파일러를 공부하고 있으므로, 이 기회에 순수 Java로 밑바닥부터 프로그래밍 언어의 파서를 구현해보기로 한다.

 물론 실제 자바 언어의 규칙들을 전부 구현하는 것은 무리가 있고, 또한 과제의 범위도 주어진 소스파일만을 정상적으로 파싱하면 된다고 하였으므로, 소스파일에 포함된 최소한의 기능만을 인식하도록 파서를 구현하였다. 따라서 제네릭이나 익명 클래스 등 복잡한 문법은 구현되어있지 않으며, 심지어 함수를 정의할 때 변수를 두 개 이상 사용하는 기능조차 없다.

# Structure

 본 프로젝트는 크게 Main, Parser, Visualizer의 세 가지 패키지로 나누어져 있다.

- Main은 main함수가 포함되어 기본적인 코드 로드 및 파싱, Visualizer호출 등을 담당한다. 
- Parser는 Java 소스코드를 파싱하는 기능들이 포함되어 있으며, 크게 Lexer와 Parser로 나누어져 있다.
- Visualizer는 파싱된 코드를 GUI로 보여주는 역할을 한다.

## Lexer
 Lexer는 정규표현식을 사용하여 구현하였다. 소스 코드에 [Lexing rule](./lex-rule.txt)을 위에서부터 적용하여, rule에 매칭되는 부분 문자열이 발견되면 그 문자열을 #으로 치환하고 해당 문자열은 Token object로 Wrapping하여 Priority queue에 저장하도록 하였다. Token에는 어떤 Lexing rule이 적용되었는지, 매칭된 부분의 시작 위치와 끝 위치 등의 정보가 포함되어있다. Priority queue는 문자열의 시작 위치를 기준으로 정렬된다. 따라서 Priority queue에는 파싱된 토큰이 원래 문자열에서 나타나는 순서대로 들어가있다.

 모든 Lexing rule을 적용하고 나면 입력 문자열의 모든 문자가 #으로 치환된다. 만약 #이 아닌 문자가 포함되어있다면 이는 어떤 토큰에도 맞지 않는 문자가 있다는 뜻으로, 그럴 경우 예외를 일으킨다. 아래는 일부 예시이다.

 다만 실제 컴파일러상에서는 위와 같은 규칙에 앞서 길이 순으로 Lexing rule을 적용한다. 즉, Lexing rule우선순위가 낮다 하더라도, 가장 긴 부분 문자열에 매칭되는 Lexing rule을 적용한다. 따라서 위와 같이 단순히 순서대로 매칭하면 몇 가지 예외가 생긴다. 예컨대 `println`이라는 문자열은 `IDENTIFIER`에 매칭되어야한다. 그러나 `IDENTIFIER`의 우선순위가 `TYPE`의 우선순위보다 낮기 때문에, 다음과 같이 매칭되어버린다.

```
pr 	: IDENTIFIER
int	: TYPE
ln 	: IDENTIFIER
```

따라서 다음과 같이 Lexing rule에 약간의 트릭을 써서 이런 문제를 회피한다.

```
TYPE : int#
```

위와 같이 하면 int라는 글자 다음에 공백이나 특수문자가 하나 이상 올 때에만 int를 `IDENTIFIER`로 인식한다. 공백 및 특수문자의 우선순위는 `TYPE`이나 `IDENTIFIER`보다 높기 때문에, 이러한 트릭을 쓸 수 있다. 물론 이것 역시 문제가 있는데, 소스코드에 print()와 같이 int로 끝나는 `IDENTIFIER`가 있으면 똑같은 문제가 발생한다는 것이다. 따라서 이런 트릭은 그런 `IDENTIFIER`가 없는 MyStack.Java에만 적용될 수 있는 것으로, 추후 수정할 필요가 있다.

#### Source code

```java
class MyStack {
	private int size;
	private int top;
	private int[] data;

	public MyStack(int size) {
		data = new int[size];
		this.size = size;
		top = 0;
	}
	... 중략
}
```

#### Lexed token

```
class	: CLASS[0,6]
MyStack	: IDENTIFIER[6,13]
{	: BRACKET_B_O[14,15]
private	: QUALIFIER[17,25]
int	: TYPE[25,29]
size	: IDENTIFIER[29,33]
;	: SPLIT[33,34]
private	: QUALIFIER[36,44]
int	: TYPE[44,48]
top	: IDENTIFIER[48,51]
;	: SPLIT[51,52]
private	: QUALIFIER[54,62]
int	: TYPE[62,66]
[	: BRACKET_A_O[65,66]
]	: BRACKET_A_C[66,67]
data	: IDENTIFIER[68,72]
;	: SPLIT[72,73]
public	: QUALIFIER[76,83]
MyStack	: IDENTIFIER[83,90]
(	: BRACKET_C_O[90,91]
int	: TYPE[91,95]
size	: IDENTIFIER[95,99]
)	: BRACKET_C_C[99,100]
{	: BRACKET_B_O[101,102]
data	: IDENTIFIER[105,109]
=	: OPERATOR_ASSIGN[110,111]
new	: NEW[112,116]
int	: TYPE[116,120]
[	: BRACKET_A_O[119,120]
size	: IDENTIFIER[120,124]
]	: BRACKET_A_C[124,125]
;	: SPLIT[125,126]
this	: THIS[129,134]
.	: OPERATOR_REFER[133,134]
size	: IDENTIFIER[134,138]
=	: OPERATOR_ASSIGN[139,140]
size	: IDENTIFIER[141,145]
;	: SPLIT[145,146]
top	: IDENTIFIER[149,152]
=	: OPERATOR_ASSIGN[153,154]
0	: NUMBER[155,156]
;	: SPLIT[156,157]
}	: BRACKET_B_C[159,160]
... 중략
}	: BRACKET_B_C[537,538]
```

Split등을 쓴 경우와 다르게, 각 토큰들이 잘 분리되었을 뿐만 아니라 무슨 의미를 가지는지도 잘 표현되어있다.

## Parser
 Parser는 다음과 같이 구현되었다. 먼저 [Parsing rule](./parse-rule.txt)은 여러 개의 토큰을 하나의 토큰으로 바꾸는 규칙을 기술한다. 이 파일을 따라 순서대로 규칙을 적용한다. 규칙을 적용한다는 것은, Parsing rule에서 오른쪽에 있는 토큰들을 왼쪽에 있는 토큰으로 치환한다는 의미이다.

 다만 상용 컴파일러-컴파일러에서는 `|`기호를 사용하거나, Parsing rule에 리터럴을 포함하면 자동으로 Lexing시에 처리해주는 기능을 포함한다. 그러나 본 프로젝트에서는 그런 기능들을 구현하지 않았으므로 하나의 이름을 가진 Parsing rule이 여러 개 있어도 되며, 리터럴이 포함되면 안 된다.

 Parsing rule을 적용하는 것은 다음의 과정을 따른다.
1. 가장 처음의 파싱 룰을 token의 배열에 딱 한 번 적용한다. 딱 한 번 적용한다 함은, Parsing rule에 매칭되는 부분이 여러 개 있더라도 가장 왼쪽의 매칭되는 부분만을 치환한다는 것이다.
2. 만약 파싱 룰을 적용하여 바뀐 부분이 있다면, 다시 1번으로 돌아간다. 없다면, 다음 단계로 간다. 바뀐 부분이 있을 경우 1번으로 돌아가는 이유는, 토큰이 바뀌면서 이미 적용한 규칙들을 한 번 더 적용할 수 있는 경우가 발생할 수도 있기 때문이다.
3. 마찬가지로 두번째의 파싱 룰을 딱 한 번 적용한다.
4. 만약 바뀐 부분이 있다면 1번으로 돌아간다. 없다면, 다음 단계로 넘어간다. 
5. 위의 과정을 모든 파싱 룰에 대해 반복한다.
6. 위와 같은 과정을 따라, 모든 룰을 다 적용한 후 마지막 파싱 룰을 적용했는데, 바뀐 부분이 없다면 파싱을 종료한다.
7. 만약 Source 및 Parsing rule에 모두 오류가 없다면, 6번까지의 과정을 마치면 토큰 하나만이 남게 된다. 그럴 경우 그 토큰을 반환하며, 만약 오류가 있어 두 개 이상의 토큰이 남게 되면 예외를 일으킨다.

 이는 시간복잡도를 따져 보면 R^2이나 R^3가 나올 수도 있는 매우 비효율적인 구현이지만, 어쨌든 다른 라이브러리의 도움 없이 정상적으로 작동하는 Parser를 구현하였다는 것에 의의를 둔다. 

## Abstract semantic tree (AST-fy)
현재 파싱 룰은 `|`기호나 `+`기호 등을 사용하여 정규표현식과 같은 방법을 적용할 수 없다. 따라서 어떤 요소의 가변 개수만큼의 나열을 위해서는 다음과 같은 방법을 사용해야만 한다.
```
codelines : codelines codeline
codelines : codeline
```
위는 codeline들의 나열을 나타내기 위하여 codelines라는 새로운 규칙을 도입한 예이다.  그러나 이런 방식으로 나열을 표시하면 직관적으로 알아보기 힘들 뿐만 아니라, 나열된 원소들 사이에 부모-자식 관계가 성립하므로 나열이라 보기도 어렵다.

나열 뿐만 아니라 여러 상황에서 Parse tree를 그대로 사용하는 것은 비효율적이다. 따라서 Parse tree를 구축한 이후에, Parse tree 내부의 특정 Token 제거하는 방법을 통하여 Parse tree를 Abstract semantic tree로 변환하였다.

이때 특정 Token을 제거한다 함은, 어떤 Token의 자식들을, 모두 그 Token의 부모의 자식으로 옮긴다는 의미이다. Pseudo code로 표현하면 다음과 같다.
```
// token = 지우고자 하는 토큰
token.parent.addChildren(token.children)
token.parent.children.remove(token)
```
이러한 과정을 거치면 구조를 나타내기 위해서만 필요한 토큰(e.g [;], [,], codelines, [{],[}]이나 식별을 위한 keyword(e.g. class, if, else, return, 연산자)등이 제거되어 유의미한 Token만이 남게 된다. 아래의 실제 soruce code 및 lexing-parsing을 진행한 결과를 확인해보면 Parse tree보다 AST가 훨씬 짧다는 것을 알 수 있다.

## Typo
Rule 및 아래의 파싱 결과 등에서 feild라 되어 있는 부분은 field의 오타이다.

## [Raw source code](./source.txt)
분석해야 할 소스코드이다.

## Lexed code
아래는 Lexing과정을 통하여 Toknize된 [Raw source code](./source.txt)이다.
공백은 Skip되었다.
```
class	: CLASS[0,6]
MyStack	: IDENTIFIER[6,13]
{	: BRACKET_B_O[14,15]
private	: QUALIFIER[17,25]
int	: TYPE[25,29]
size	: IDENTIFIER[29,33]
;	: SPLIT[33,34]
private	: QUALIFIER[36,44]
int	: TYPE[44,48]
top	: IDENTIFIER[48,51]
;	: SPLIT[51,52]
private	: QUALIFIER[54,62]
int	: TYPE[62,66]
[	: BRACKET_A_O[65,66]
]	: BRACKET_A_C[66,67]
data	: IDENTIFIER[68,72]
;	: SPLIT[72,73]
public	: QUALIFIER[76,83]
MyStack	: IDENTIFIER[83,90]
(	: BRACKET_C_O[90,91]
int	: TYPE[91,95]
size	: IDENTIFIER[95,99]
)	: BRACKET_C_C[99,100]
{	: BRACKET_B_O[101,102]
data	: IDENTIFIER[105,109]
=	: OPERATOR_ASSIGN[110,111]
new	: NEW[112,116]
int	: TYPE[116,120]
[	: BRACKET_A_O[119,120]
size	: IDENTIFIER[120,124]
]	: BRACKET_A_C[124,125]
;	: SPLIT[125,126]
this	: THIS[129,134]
.	: OPERATOR_REFER[133,134]
size	: IDENTIFIER[134,138]
=	: OPERATOR_ASSIGN[139,140]
size	: IDENTIFIER[141,145]
;	: SPLIT[145,146]
top	: IDENTIFIER[149,152]
=	: OPERATOR_ASSIGN[153,154]
0	: NUMBER[155,156]
;	: SPLIT[156,157]
}	: BRACKET_B_C[159,160]
public	: QUALIFIER[163,170]
void	: TYPE[170,175]
push	: IDENTIFIER[175,179]
(	: BRACKET_C_O[179,180]
int	: TYPE[180,184]
v	: IDENTIFIER[184,185]
)	: BRACKET_C_C[185,186]
{	: BRACKET_B_O[187,188]
if	: IF[191,194]
(	: BRACKET_C_O[193,194]
!	: OPERATOR_NOT[194,195]
isFull	: IDENTIFIER[195,201]
(	: BRACKET_C_O[201,202]
)	: BRACKET_C_C[202,203]
)	: BRACKET_C_C[203,204]
data	: IDENTIFIER[208,212]
[	: BRACKET_A_O[212,213]
top	: IDENTIFIER[213,216]
++	: OPERATOR_TWO_UNI[216,218]
]	: BRACKET_A_C[218,219]
=	: OPERATOR_ASSIGN[220,221]
v	: IDENTIFIER[222,223]
;	: SPLIT[223,224]
else	: ELSE[227,232]
System	: IDENTIFIER[235,241]
.	: OPERATOR_REFER[241,242]
out	: IDENTIFIER[242,245]
.	: OPERATOR_REFER[245,246]
println	: IDENTIFIER[246,253]
(	: BRACKET_C_O[253,254]
"Stack is full"	: STRING[254,269]
)	: BRACKET_C_C[269,270]
;	: SPLIT[270,271]
}	: BRACKET_B_C[273,274]
public	: QUALIFIER[277,284]
int	: TYPE[284,288]
pop	: IDENTIFIER[288,291]
(	: BRACKET_C_O[291,292]
)	: BRACKET_C_C[292,293]
{	: BRACKET_B_O[294,295]
if	: IF[298,301]
(	: BRACKET_C_O[300,301]
!	: OPERATOR_NOT[301,302]
isEmpty	: IDENTIFIER[302,309]
(	: BRACKET_C_O[309,310]
)	: BRACKET_C_C[310,311]
)	: BRACKET_C_C[311,312]
return	: RETURN[316,323]
data	: IDENTIFIER[323,327]
[	: BRACKET_A_O[327,328]
--	: OPERATOR_TWO_UNI[328,330]
top	: IDENTIFIER[330,333]
]	: BRACKET_A_C[333,334]
;	: SPLIT[334,335]
else	: ELSE[338,343]
return	: RETURN[346,353]
-	: OPERATOR_PLUSMINUS[353,354]
1	: NUMBER[354,355]
;	: SPLIT[355,356]
}	: BRACKET_B_C[358,359]
public	: QUALIFIER[362,369]
boolean	: TYPE[369,377]
isFull	: IDENTIFIER[377,383]
(	: BRACKET_C_O[383,384]
)	: BRACKET_C_C[384,385]
{	: BRACKET_B_O[386,387]
if	: IF[390,393]
(	: BRACKET_C_O[392,393]
top	: IDENTIFIER[393,396]
>=	: OPERATOR_COMP[397,399]
size	: IDENTIFIER[400,404]
)	: BRACKET_C_C[404,405]
return	: RETURN[409,416]
true	: BOOLEAN[416,421]
;	: SPLIT[420,421]
else	: ELSE[424,429]
return	: RETURN[432,439]
false	: BOOLEAN[439,445]
;	: SPLIT[444,445]
}	: BRACKET_B_C[447,448]
public	: QUALIFIER[451,458]
boolean	: TYPE[458,466]
isEmpty	: IDENTIFIER[466,473]
(	: BRACKET_C_O[473,474]
)	: BRACKET_C_C[474,475]
{	: BRACKET_B_O[476,477]
if	: IF[480,483]
(	: BRACKET_C_O[483,484]
top	: IDENTIFIER[484,487]
==	: OPERATOR_COMP[488,490]
0	: NUMBER[491,492]
)	: BRACKET_C_C[492,493]
return	: RETURN[497,504]
true	: BOOLEAN[504,509]
;	: SPLIT[508,509]
else	: ELSE[512,517]
return	: RETURN[520,527]
false	: BOOLEAN[527,533]
;	: SPLIT[532,533]
}	: BRACKET_B_C[535,536]
}	: BRACKET_B_C[537,538]
```
## Parse tree
아래는 위 결과를 [Parsing rule](./parse-rule.txt)에 따라 Parse한 것이다.
```
class_full[0]
    class_def[0]
        class	: CLASS[0,6]
        MyStack	: IDENTIFIER[6,13]
    {	: BRACKET_B_O[14,15]
    feilds[2]
        feilds[2]
            feilds[2]
                feilds[2]
                    feilds[2]
                        feilds[2]
                            feilds[2]
                                feilds[2]
                                    feild[2]
                                        var_def_full[3]
                                            var_def[3]
                                                private	: QUALIFIER[17,25]
                                                type[4]
                                                    int	: TYPE[25,29]
                                                size	: IDENTIFIER[29,33]
                                            ;	: SPLIT[33,34]
                                feild[3]
                                    var_def_full[4]
                                        var_def[5]
                                            private	: QUALIFIER[36,44]
                                            type[8]
                                                int	: TYPE[44,48]
                                            top	: IDENTIFIER[48,51]
                                        ;	: SPLIT[51,52]
                            feild[4]
                                var_def_full[5]
                                    var_def[7]
                                        private	: QUALIFIER[54,62]
                                        type[12]
                                            int	: TYPE[62,66]
                                            [	: BRACKET_A_O[65,66]
                                            ]	: BRACKET_A_C[66,67]
                                        data	: IDENTIFIER[68,72]
                                    ;	: SPLIT[72,73]
                        feild[5]
                            constructor_full[5]
                                constructor_def[5]
                                    public	: QUALIFIER[76,83]
                                    MyStack	: IDENTIFIER[83,90]
                                    (	: BRACKET_C_O[90,91]
                                    var_def[12]
                                        type[18]
                                            int	: TYPE[91,95]
                                        size	: IDENTIFIER[95,99]
                                    )	: BRACKET_C_C[99,100]
                                codeblock[6]
                                    {	: BRACKET_B_O[101,102]
                                    codelines[7]
                                        codelines[7]
                                            codelines[7]
                                                codeline[7]
                                                    exp[7]
                                                        op_assign[7]
                                                            exp[7]
                                                                data	: IDENTIFIER[105,109]
                                                            =	: OPERATOR_ASSIGN[110,111]
                                                            exp[9]
                                                                op_new[9]
                                                                    new	: NEW[112,116]
                                                                    type_arr[10]
                                                                        type[25]
                                                                            int	: TYPE[116,120]
                                                                        [	: BRACKET_A_O[119,120]
                                                                        exp[12]
                                                                            size	: IDENTIFIER[120,124]
                                                                        ]	: BRACKET_A_C[124,125]
                                                    ;	: SPLIT[125,126]
                                            codeline[8]
                                                exp[9]
                                                    op_assign[9]
                                                        exp[15]
                                                            refer[15]
                                                                this	: THIS[129,134]
                                                                .	: OPERATOR_REFER[133,134]
                                                                exp[17]
                                                                    size	: IDENTIFIER[134,138]
                                                        =	: OPERATOR_ASSIGN[139,140]
                                                        exp[19]
                                                            size	: IDENTIFIER[141,145]
                                                ;	: SPLIT[145,146]
                                        codeline[9]
                                            exp[11]
                                                op_assign[11]
                                                    exp[21]
                                                        top	: IDENTIFIER[149,152]
                                                    =	: OPERATOR_ASSIGN[153,154]
                                                    exp[23]
                                                        0	: NUMBER[155,156]
                                            ;	: SPLIT[156,157]
                                    }	: BRACKET_B_C[159,160]
                    feild[6]
                        function_full[6]
                            function_def[30]
                                var_def[35]
                                    public	: QUALIFIER[163,170]
                                    type[42]
                                        void	: TYPE[170,175]
                                    push	: IDENTIFIER[175,179]
                                (	: BRACKET_C_O[179,180]
                                var_def[36]
                                    type[45]
                                        int	: TYPE[180,184]
                                    v	: IDENTIFIER[184,185]
                                )	: BRACKET_C_C[185,186]
                            codeblock[7]
                                {	: BRACKET_B_O[187,188]
                                codelines[8]
                                    codeline[8]
                                        if_else[8]
                                            if[8]
                                                if_condition[22]
                                                    if	: IF[191,194]
                                                    (	: BRACKET_C_O[193,194]
                                                    exp[24]
                                                        op_not[24]
                                                            !	: OPERATOR_NOT[194,195]
                                                            exp[29]
                                                                func_call[29]
                                                                    exp[31]
                                                                        isFull	: IDENTIFIER[195,201]
                                                                    (	: BRACKET_C_O[201,202]
                                                                    )	: BRACKET_C_C[202,203]
                                                    )	: BRACKET_C_C[203,204]
                                                codeblock[9]
                                                    codelines[12]
                                                        codeline[14]
                                                            exp[17]
                                                                op_assign[17]
                                                                    exp[23]
                                                                        op_array[23]
                                                                            exp[35]
                                                                                data	: IDENTIFIER[208,212]
                                                                            [	: BRACKET_A_O[212,213]
                                                                            exp[25]
                                                                                op_two_back[25]
                                                                                    exp[37]
                                                                                        top	: IDENTIFIER[213,216]
                                                                                    ++	: OPERATOR_TWO_UNI[216,218]
                                                                            ]	: BRACKET_A_C[218,219]
                                                                    =	: OPERATOR_ASSIGN[220,221]
                                                                    exp[41]
                                                                        v	: IDENTIFIER[222,223]
                                                            ;	: SPLIT[223,224]
                                            else[9]
                                                else	: ELSE[227,232]
                                                codeblock[10]
                                                    codelines[14]
                                                        codeline[16]
                                                            exp[40]
                                                                func_call[40]
                                                                    exp[42]
                                                                        refer[42]
                                                                            exp[42]
                                                                                refer[42]
                                                                                    exp[44]
                                                                                        System	: IDENTIFIER[235,241]
                                                                                    .	: OPERATOR_REFER[241,242]
                                                                                    exp[46]
                                                                                        out	: IDENTIFIER[242,245]
                                                                            .	: OPERATOR_REFER[245,246]
                                                                            exp[48]
                                                                                println	: IDENTIFIER[246,253]
                                                                    (	: BRACKET_C_O[253,254]
                                                                    exp[50]
                                                                        "Stack is full"	: STRING[254,269]
                                                                    )	: BRACKET_C_C[269,270]
                                                            ;	: SPLIT[270,271]
                                }	: BRACKET_B_C[273,274]
                feild[7]
                    function_full[7]
                        function_def[61]
                            var_def[67]
                                public	: QUALIFIER[277,284]
                                type[76]
                                    int	: TYPE[284,288]
                                pop	: IDENTIFIER[288,291]
                            (	: BRACKET_C_O[291,292]
                            )	: BRACKET_C_C[292,293]
                        codeblock[8]
                            {	: BRACKET_B_O[294,295]
                            codelines[9]
                                codeline[9]
                                    if_else[12]
                                        if[12]
                                            if_condition[37]
                                                if	: IF[298,301]
                                                (	: BRACKET_C_O[300,301]
                                                exp[39]
                                                    op_not[42]
                                                        !	: OPERATOR_NOT[301,302]
                                                        exp[48]
                                                            func_call[51]
                                                                exp[59]
                                                                    isEmpty	: IDENTIFIER[302,309]
                                                                (	: BRACKET_C_O[309,310]
                                                                )	: BRACKET_C_C[310,311]
                                                )	: BRACKET_C_C[311,312]
                                            codeblock[13]
                                                codelines[19]
                                                    codeline[26]
                                                        return[26]
                                                            return	: RETURN[316,323]
                                                            exp[35]
                                                                op_array[35]
                                                                    exp[64]
                                                                        data	: IDENTIFIER[323,327]
                                                                    [	: BRACKET_A_O[327,328]
                                                                    exp[40]
                                                                        op_two_front[40]
                                                                            --	: OPERATOR_TWO_UNI[328,330]
                                                                            exp[67]
                                                                                top	: IDENTIFIER[330,333]
                                                                    ]	: BRACKET_A_C[333,334]
                                                        ;	: SPLIT[334,335]
                                        else[13]
                                            else	: ELSE[338,343]
                                            codeblock[14]
                                                codelines[21]
                                                    codeline[28]
                                                        return[29]
                                                            return	: RETURN[346,353]
                                                            exp[45]
                                                                op_sign[45]
                                                                    -	: OPERATOR_PLUSMINUS[353,354]
                                                                    exp[73]
                                                                        1	: NUMBER[354,355]
                                                        ;	: SPLIT[355,356]
                            }	: BRACKET_B_C[358,359]
            feild[8]
                function_full[8]
                    function_def[83]
                        var_def[91]
                            public	: QUALIFIER[362,369]
                            type[102]
                                boolean	: TYPE[369,377]
                            isFull	: IDENTIFIER[377,383]
                        (	: BRACKET_C_O[383,384]
                        )	: BRACKET_C_C[384,385]
                    codeblock[9]
                        {	: BRACKET_B_O[386,387]
                        codelines[10]
                            codeline[10]
                                if_else[16]
                                    if[16]
                                        if_condition[36]
                                            if	: IF[390,393]
                                            (	: BRACKET_C_O[392,393]
                                            exp[38]
                                                op_compare[38]
                                                    exp[80]
                                                        top	: IDENTIFIER[393,396]
                                                    >=	: OPERATOR_COMP[397,399]
                                                    exp[82]
                                                        size	: IDENTIFIER[400,404]
                                            )	: BRACKET_C_C[404,405]
                                        codeblock[17]
                                            codelines[26]
                                                codeline[33]
                                                    return[35]
                                                        return	: RETURN[409,416]
                                                        exp[85]
                                                            true	: BOOLEAN[416,421]
                                                    ;	: SPLIT[420,421]
                                    else[17]
                                        else	: ELSE[424,429]
                                        codeblock[18]
                                            codelines[28]
                                                codeline[35]
                                                    return[38]
                                                        return	: RETURN[432,439]
                                                        exp[89]
                                                            false	: BOOLEAN[439,445]
                                                    ;	: SPLIT[444,445]
                        }	: BRACKET_B_C[447,448]
        feild[9]
            function_full[9]
                function_def[99]
                    var_def[109]
                        public	: QUALIFIER[451,458]
                        type[122]
                            boolean	: TYPE[458,466]
                        isEmpty	: IDENTIFIER[466,473]
                    (	: BRACKET_C_O[473,474]
                    )	: BRACKET_C_C[474,475]
                codeblock[10]
                    {	: BRACKET_B_O[476,477]
                    codelines[11]
                        codeline[11]
                            if_else[20]
                                if[20]
                                    if_condition[47]
                                        if	: IF[480,483]
                                        (	: BRACKET_C_O[483,484]
                                        exp[49]
                                            op_compare[52]
                                                exp[96]
                                                    top	: IDENTIFIER[484,487]
                                                ==	: OPERATOR_COMP[488,490]
                                                exp[98]
                                                    0	: NUMBER[491,492]
                                        )	: BRACKET_C_C[492,493]
                                    codeblock[21]
                                        codelines[33]
                                            codeline[40]
                                                return[44]
                                                    return	: RETURN[497,504]
                                                    exp[101]
                                                        true	: BOOLEAN[504,509]
                                                ;	: SPLIT[508,509]
                                else[21]
                                    else	: ELSE[512,517]
                                    codeblock[22]
                                        codelines[35]
                                            codeline[42]
                                                return[47]
                                                    return	: RETURN[520,527]
                                                    exp[105]
                                                        false	: BOOLEAN[527,533]
                                                ;	: SPLIT[532,533]
                    }	: BRACKET_B_C[535,536]
    }	: BRACKET_B_C[537,538]
```

## AST
아래는 위의 Parse tree에서 몇 개의 규칙을 skip하는 방법을 통해 AST를 구축한 것이다.
이렇게 만든 AST는 Parse tree의 subset에 불과하므로, 진정한 의미에서의 AST라고는 할 수 없으나, 그래도 Parse tree에 비하여 매우 가독성이 높고 모든 노드가 유의미하다.
```
class_full[0]
    class_def[0]
        MyStack	: IDENTIFIER[6,13]
    feild[2]
        var_def_full[3]
            var_def[3]
                private	: QUALIFIER[17,25]
                type[4]
                    int	: TYPE[25,29]
                size	: IDENTIFIER[29,33]
    feild[3]
        var_def_full[4]
            var_def[5]
                private	: QUALIFIER[36,44]
                type[8]
                    int	: TYPE[44,48]
                top	: IDENTIFIER[48,51]
    feild[4]
        var_def_full[5]
            var_def[7]
                private	: QUALIFIER[54,62]
                type[12]
                    int	: TYPE[62,66]
                data	: IDENTIFIER[68,72]
    feild[5]
        constructor_full[5]
            constructor_def[5]
                public	: QUALIFIER[76,83]
                MyStack	: IDENTIFIER[83,90]
                var_def[12]
                    type[18]
                        int	: TYPE[91,95]
                    size	: IDENTIFIER[95,99]
            codeblock[6]
                op_assign[7]
                    data	: IDENTIFIER[105,109]
                    op_new[9]
                        type_arr[10]
                            type[25]
                                int	: TYPE[116,120]
                            size	: IDENTIFIER[120,124]
                op_assign[9]
                    refer[15]
                        this	: THIS[129,134]
                        size	: IDENTIFIER[134,138]
                    size	: IDENTIFIER[141,145]
                op_assign[11]
                    top	: IDENTIFIER[149,152]
                    0	: NUMBER[155,156]
    feild[6]
        function_full[6]
            function_def[30]
                var_def[35]
                    public	: QUALIFIER[163,170]
                    type[42]
                        void	: TYPE[170,175]
                    push	: IDENTIFIER[175,179]
                var_def[36]
                    type[45]
                        int	: TYPE[180,184]
                    v	: IDENTIFIER[184,185]
            codeblock[7]
                if_else[8]
                    if[8]
                        if_condition[22]
                            op_not[24]
                                func_call[29]
                                    isFull	: IDENTIFIER[195,201]
                        codeblock[9]
                            op_assign[17]
                                op_array[23]
                                    data	: IDENTIFIER[208,212]
                                    op_two_back[25]
                                        top	: IDENTIFIER[213,216]
                                        ++	: OPERATOR_TWO_UNI[216,218]
                                v	: IDENTIFIER[222,223]
                    else[9]
                        codeblock[10]
                            func_call[40]
                                refer[42]
                                    refer[42]
                                        System	: IDENTIFIER[235,241]
                                        out	: IDENTIFIER[242,245]
                                    println	: IDENTIFIER[246,253]
                                "Stack is full"	: STRING[254,269]
    feild[7]
        function_full[7]
            function_def[61]
                var_def[67]
                    public	: QUALIFIER[277,284]
                    type[76]
                        int	: TYPE[284,288]
                    pop	: IDENTIFIER[288,291]
            codeblock[8]
                if_else[12]
                    if[12]
                        if_condition[37]
                            op_not[42]
                                func_call[51]
                                    isEmpty	: IDENTIFIER[302,309]
                        codeblock[13]
                            return[26]
                                op_array[35]
                                    data	: IDENTIFIER[323,327]
                                    op_two_front[40]
                                        --	: OPERATOR_TWO_UNI[328,330]
                                        top	: IDENTIFIER[330,333]
                    else[13]
                        codeblock[14]
                            return[29]
                                op_sign[45]
                                    -	: OPERATOR_PLUSMINUS[353,354]
                                    1	: NUMBER[354,355]
    feild[8]
        function_full[8]
            function_def[83]
                var_def[91]
                    public	: QUALIFIER[362,369]
                    type[102]
                        boolean	: TYPE[369,377]
                    isFull	: IDENTIFIER[377,383]
            codeblock[9]
                if_else[16]
                    if[16]
                        if_condition[36]
                            op_compare[38]
                                top	: IDENTIFIER[393,396]
                                >=	: OPERATOR_COMP[397,399]
                                size	: IDENTIFIER[400,404]
                        codeblock[17]
                            return[35]
                                true	: BOOLEAN[416,421]
                    else[17]
                        codeblock[18]
                            return[38]
                                false	: BOOLEAN[439,445]
    feild[9]
        function_full[9]
            function_def[99]
                var_def[109]
                    public	: QUALIFIER[451,458]
                    type[122]
                        boolean	: TYPE[458,466]
                    isEmpty	: IDENTIFIER[466,473]
            codeblock[10]
                if_else[20]
                    if[20]
                        if_condition[47]
                            op_compare[52]
                                top	: IDENTIFIER[484,487]
                                ==	: OPERATOR_COMP[488,490]
                                0	: NUMBER[491,492]
                        codeblock[21]
                            return[44]
                                true	: BOOLEAN[504,509]
                    else[21]
                        codeblock[22]
                            return[47]
                                false	: BOOLEAN[527,533]


```